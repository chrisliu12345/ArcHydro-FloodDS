# Floodhandbase.py
# Created on: 2016-11-04 12:04:55.00000
#   (generated by ArcGIS/ModelBuilder)
# Usage: FloodHandBaseM <fillgridsub> <Multiplier> <str> <pFolder> <catchment>  catchment is optional, if provided, handop will be applied catchment by catchment.
# Description:
#   construct HAND (Height Above Nearest Drainage Point), Multiplier=100, is used to multiply the fill and make it an int grid, as nibble works only on int grid.
#   str=[value=1], is used as the seed to define the locus of the lowest point, assuming str defines the thalweg of a river.
#   pScratchworkspace = "":using default scratchworkspace, "in_memory":using inmemory scratchworkspace, "scratchGDB":using scratchGDB  
# ---------------------------------------------------------------------------

# Import arcpy module
import os
import time  
import arcpy
import apwrutils 

FD_HANDBase = "HANDBASE"
LN_NibbleBase = "NibbleBase"
LN_LocalMin = "MinLocal"
LN_HANDBase = "HANDBASE"
LN_LM = "LMIN"
LN_HB = "BASE"

pScratchWorkspace =  arcpy.env.scratchGDB   # "in_memory"    #arcpy.env.scratchGDB   # "in_memory"  #r"D:\Temp\Scratch.gdb"    # "%scratchworkspace%" [does not work]  # r"C:\Temp\Scratch.gdb" # r"D:\Temp\scratch.gdb"

def trace():
    import traceback, inspect
    tb = sys.exc_info()[2]
    tbinfo = traceback.format_tb(tb)[0]
    # script name + line number
    line = tbinfo.split(", ")[1]
    filename = inspect.getfile(inspect.currentframe())
    # Get Python syntax error
    synerror = traceback.format_exc().splitlines()[-1]
    return line, filename, synerror

""" Making the ApUniqueID table """
class ApHANDCreator:
    #variables:
    def __init__(self):
        self.DebugLevel = 0

    def __exit__(self, type, value, traceback):
        if((self.DebugLevel & 2) ==2):
            apwrutils.Utils.ShowMsg(self.thisFileName() + " completed at " + time.ctime()) 
             
    def thisFileName(self):
        import inspect
        return inspect.getfile(inspect.currentframe())
    # Load the configuration xml.
    
    def getWorkspace(self, pFL):
        oDesc = arcpy.Describe(pFL)
        ooDesc = arcpy.Describe(oDesc.path)
        if(ooDesc.dataType=='FeatureDataset'):
            sWorkspace = ooDesc.path
        else:
            sWorkspace = oDesc.path

        return sWorkspace
    
    """ Construct HANDBase 
      pParams = (dem, multiplier, str, pFolder, pFLCatchment), when pFLCatcument!=None, the operations will be applied on each Catchment, and later mosaiced into the final results.
      The function returns tuple tReturn = (sOK, pHandBase, pLocalMin) 
      When debugLevel > 0, pNibbleBase would be saved for debugging.  pNibbleBase = int(pLocalMin*multiplier)
      2016/09
    """
    def execute(self, pParams):
        sOK = apwrutils.C_OK 
        ds = time.clock()
        ds1 = time.clock()
        arcpy.env.parallelProcessingFactor = "50%"
        if(self.DebugLevel>0): arcpy.AddMessage("arcpy.Exists({})={}, arcpy.env.scratchWorkspace={}".format(pScratchWorkspace, arcpy.Exists(pScratchWorkspace), arcpy.env.scratchWorkspace))
        if(pScratchWorkspace!=""): 
            if(arcpy.Exists(pScratchWorkspace)):
                arcpy.env.scratchWorkspace = pScratchWorkspace
        
        if(self.DebugLevel>0):
            arcpy.AddMessage("arcpy.Exists({})={}, arcpy.env.scratchWorkspace={}".format(pScratchWorkspace, arcpy.Exists(pScratchWorkspace), arcpy.env.scratchWorkspace))
            arcpy.AddMessage("arcpy.env.scratchFolder={}, arcpy.Exists(arcpy.env.scratchFolder)={}".format(arcpy.env.scratchFolder, arcpy.Exists(arcpy.env.scratchFolder)))        

        sp=" "
        try:
            (dem, multiplier, str, pFolder, pFLCatchment) = pParams
            rdem = arcpy.sa.Raster(dem)
            cellSize = rdem.meanCellWidth
            arcpy.env.cellSize = cellSize
            arcpy.env.snapRaster = rdem.catalogPath   #SnapRaster
            arcpy.env.overwriteOutput = True
            arcpy.env.addOutputsToMap = False
            oDesc = arcpy.Describe(dem) 
            sNamedem = oDesc.name 
            timedem = arcpy.sa.Times(dem, multiplier)   # Process: Times
            arcpy.AddMessage("{}Apply multiplier to {}. dt={}".format(sp*2, sNamedem, apwrutils.Utils.GetDSMsg(ds1,"")))
            ds1 = time.clock()
            intDEM = arcpy.sa.Int(timedem)              # Process: Int   
            arcpy.AddMessage("{}Apply int on the multiplied raster {}. dt={}".format(sp*2,sNamedem, apwrutils.Utils.GetDSMsg(ds1,"")))

            pRFolderBase = os.path.join(pFolder, FD_HANDBase) 

            if(os.path.exists(pRFolderBase)==False):
                apwrutils.Utils.makeSureDirExists(pRFolderBase) 
            if((pFLCatchment==None) or (pFLCatchment=="")):
                pNibbleBase = os.path.join(pRFolderBase, LN_NibbleBase) 
                pLocalMin = os.path.join(pRFolderBase, LN_LocalMin) 
                pHandBase = os.path.join(pRFolderBase, LN_HANDBase)    
                ds1 = time.clock()
                pNibbleBase = arcpy.sa.Nibble(intDEM, str, "All_VALUES")  # Process: Nibble
                arcpy.AddMessage("{}Apply nibble operation on int dem of {} with {} as mask. dt={}".format(sp*2,sNamedem, str, apwrutils.Utils.GetDSMsg(ds1,"")))
                ds1 = time.clock()
                multiplier = float(multiplier)
                pLocalMin = arcpy.sa.FloatDivide(pNibbleBase, multiplier) # Process: Divide
                arcpy.AddMessage("{}Apply divid operation on int nibbling results. dt={}".format(sp*2,apwrutils.Utils.GetDSMsg(ds1,"")))
                ds1 = time.clock()
                pHandBase = arcpy.sa.Minus(dem, pLocalMin)    # Process: Minus
                arcpy.AddMessage("{}Apply arcpy.sa.Minus(dem, pLocalMin) to produce HANDBASE. dt={}".format(sp*2,apwrutils.Utils.GetDSMsg(ds1,"")))
                pHandBase = arcpy.sa.Con(pHandBase, 0, pHandBase, "value < 0")
                rdsHandBase = os.path.join(pRFolderBase, LN_HANDBase)
                rdsLocalMin = os.path.join(pRFolderBase, LN_LocalMin)     
                    
                pHandBase.save(rdsHandBase) 
                pLocalMin.save(rdsLocalMin) 
                if(pProcessor.DebugLevel>0):
                    rdsNibbleBase = os.path.join(pRFolderBase, LN_NibbleBase) 
                    pNibbleBase.save(rdsNibbleBase) 
            else:
                #..the following 3 names will be used for the final 
                pNibbleBase = os.path.join(pRFolderBase, LN_NibbleBase) 
                pLocalMin = os.path.join(pRFolderBase, LN_LocalMin) 
                pHandBase = os.path.join(pRFolderBase, LN_HANDBase)    
                 
                pCATPath = os.path.join(pFolder, "CATPath")
                apwrutils.Utils.makeSureDirExists(pCATPath) 

                pCatHandBasePath = os.path.join(pCATPath, "CATHandBase")
                apwrutils.Utils.makeSureDirExists(pCatHandBasePath)
                pCatLocalMinPath = os.path.join(pCATPath, "CatLocalMin")
                apwrutils.Utils.makeSureDirExists(pCatLocalMinPath)
                pCatNibbleBasePath = os.path.join(pCATPath, "CATNibbleBase")
                if(pProcessor.DebugLevel>0):
                    apwrutils.Utils.makeSureDirExists(pCatNibbleBasePath)

                oDesc = arcpy.Describe(pFLCatchment)
                oidFieldName = oDesc.oidFieldName
                sr = oDesc.spatialReference
                ds1 = time.clock()
                nCnt = int(arcpy.GetCount_management(pFLCatchment)[0])
                arcpy.AddMessage( "{}Processing {} catchments.".format(sp*2,nCnt))
                nMod = 1
                if (nCnt>10):
                    nMod = int(nCnt/10)
                #arcpy.SetProgressor('step', 'Processing {} catchments.'.format(nCnt), 0, nCnt, nMod)      
                multiplier = float(multiplier)
                sLocalMinNames = ""
                sNibbleNames = ""
                sHandBaseNames = ""
                ds1 = time.clock()
                dds1 = time.clock()
                with arcpy.da.SearchCursor(pFLCatchment, [apwrutils.FN_ShapeAt, oidFieldName]) as rows:
                    for i, row in enumerate(rows):
                        pPolyGeom = row[0]
                        oid = row[1]
                        try:
                            catStr = arcpy.sa.ExtractByMask(str, pPolyGeom)
                            catIntDem = arcpy.sa.ExtractByMask(intDEM, pPolyGeom)
                            pCatNibbleBase = arcpy.sa.Nibble(catIntDem, catStr, "All_VALUES")  # Process: Nibble
                            pCatHandBase = arcpy.sa.Minus(catIntDem, pCatNibbleBase)    # Process: Minus
                            pCatLocalMin = arcpy.sa.FloatDivide(pCatNibbleBase, multiplier) # Process: Divide
                            pCatHandBase = arcpy.sa.FloatDivide(pCatHandBase, multiplier) 
                            pCatHandBase = arcpy.sa.Con(pCatHandBase, 0, pCatHandBase, "value < 0")
                                          
                            sLocalMinName = "{}{}".format(LN_LM,oid)
                            sNibbleName = "{}{}".format(LN_NibbleBase,oid)
                            sHandBaseName =  "{}{}".format(LN_HB,oid)
                        
                            rdsLocalMin = os.path.join(pCatLocalMinPath, sLocalMinName)  
                            rdsHandBase = os.path.join(pCatHandBasePath, sHandBaseName ) 
                            pCatHandBase.save(rdsHandBase)                             
                            pCatLocalMin.save(rdsLocalMin)

                            #..Construct 2 raster names for later mosaic (3 if nibblebase is included)
                            if(sLocalMinNames==""):
                                sLocalMinNames = sLocalMinName
                            else:
                                sLocalMinNames = "{};{}".format(sLocalMinNames, sLocalMinName)

                            if(sHandBaseNames==""):
                                sHandBaseNames = sHandBaseName
                            else:
                                sHandBaseNames = "{};{}".format(sHandBaseNames, sHandBaseName)

                            if(pProcessor.DebugLevel>0): 
                                rdsNibbleBase = os.path.join(pCatNibbleBasePath, sNibbleName ) 
                                pCatNibbleBase.save(rdsNibbleBase) 
                                if(sNibbleNames==""):
                                    sNibbleNames = sNibbleName
                                else:
                                    sNibbleNames = "{};{}".format(sNibbleNames, sNibbleName)

                            if(i % nMod)==0:
                                sMsg = "{}Processing {} of {} catchments. ddt={}".format(sp*4, i+1, nCnt,  apwrutils.Utils.GetDSMsg(dds1,""))
                                arcpy.SetProgressorLabel(sMsg)
                                arcpy.AddMessage(sMsg) 
                                arcpy.SetProgressorPosition(i+1)
                                dds1 = time.clock()
                        except:
                            arcpy.AddWarning("{} {}".format(arcpy.GetMessages(2), trace()))
                            pass

                sMsg = "{}Completed processing {} of {} catchments. dt={}".format(sp*2,  nCnt, nCnt,  apwrutils.Utils.GetDSMsg(ds1,""))
                arcpy.AddMessage(sMsg) 
                ds1 = time.clock()
                #Construct mosaic DS:
                arcpy.env.workspace = pCatLocalMinPath
                arcpy.MosaicToNewRaster_management(sLocalMinNames, pRFolderBase, LN_LocalMin, sr, "8_BIT_UNSIGNED", cellSize, "1", "LAST","FIRST") 
                sMsg = "{}Mosaic {} catchment LocalMin to form the LocalMin raster. dt={}".format(sp*2,nCnt, apwrutils.Utils.GetDSMsg(ds1,"") )
                arcpy.AddMessage(sMsg) 
                ds1 = time.clock()

                arcpy.env.workspace = pCatHandBasePath
                arcpy.MosaicToNewRaster_management(sHandBaseNames, pRFolderBase, LN_HANDBase, sr, "8_BIT_UNSIGNED", cellSize, "1", "LAST","FIRST") 
                sMsg = "{}Mosaic {} catchment Handbase to form the HandBase raster. dt={}".format(sp*2,nCnt, apwrutils.Utils.GetDSMsg(ds1,"") )
                arcpy.AddMessage(sMsg) 
                ds1 = time.clock()

                if(pProcessor.DebugLevel>0):            
                    arcpy.env.workspace = pCatNibbleBasePath
                    arcpy.MosaicToNewRaster_management(sNibbleNames, pRFolderBase, LN_NibbleBase, sr, "8_BIT_UNSIGNED", cellSize, "1", "LAST","FIRST") 
                    sMsg = "{}Mosaic {} catchment Nibble to form the NibbleBase raster. dt={}".format(sp*2,nCnt, apwrutils.Utils.GetDSMsg(ds1,"") )
                    arcpy.AddMessage(sMsg) 
                    ds1 = time.clock()

            arcpy.AddMessage("Saving the Handbase result rasters. dt={}".format(apwrutils.Utils.GetDSMsg(ds,"")))
            ds = time.clock()
            sOK = apwrutils.C_OK   

        except:
            arcpy.AddError("{}{}".format(arcpy.GetMessages(2), trace()))
            sOK = apwrutils.C_NOTOK
        finally:
            arcpy.ResetEnvironments()
            if(self.DebugLevel>0):
                arcpy.AddMessage("arcpy.env.workspace={}".format(arcpy.env.workspace))
                arcpy.AddMessage("arcpy.env.cellSize={}".format(arcpy.env.cellSize))
                arcpy.AddMessage("arcpy.env.snapRaster={}".format(arcpy.env.snapRaster))
                arcpy.AddMessage("arcpy.env.overwriteOutput={}".format(arcpy.env.overwriteOutput ))
                arcpy.AddMessage("arcpy.env.addOutputsToMap={}".format(arcpy.env.addOutputsToMap))
                arcpy.AddMessage("arcpy.env.parallelProcessingFactor={}".format(arcpy.env.parallelProcessingFactor))
        return (sOK, pHandBase, pLocalMin)


if(__name__=='__main__'):
    debugLevel = 0
    dem = arcpy.GetParameterAsText(0)
    multiplier = arcpy.GetParameterAsText(1)
    str = arcpy.GetParameterAsText(2)
    pFolder = arcpy.GetParameterAsText(3)
    pFLCatchment = arcpy.GetParameterAsText(4)
    
    ds = time.clock()
    arcpy.env.overwriteOutput = True 
    if dem == '#' or not dem:
        dem = "dem" # provide a default value if unspecified
    if multiplier == '#' or not multiplier:
        multiplier = "100" # provide a default value if unspecified
    try:
        multiplier = int(multiplier)
    except:
        multiplier = 100

    if str == '#' or not str:
        str = "str" # provide a default value if unspecified

    if(os.path.exists(pFolder)==False):
        apwrutils.Utils.makeSureDirExists(pFolder) 

    pParams = (dem, multiplier, str, pFolder, pFLCatchment) 
    pProcessor = ApHANDCreator()
    pProcessor.DebugLevel = debugLevel
    tReturns = pProcessor.execute(pParams)       
    if(tReturns[0] == apwrutils.C_OK): 
        pHandBase = tReturns[1]
        pLocalMin = tReturns[2] 

        pRLHandBase = LN_HANDBase
        pRLLocalMin = LN_LocalMin

        arcpy.MakeRasterLayer_management(pHandBase, pRLHandBase) 
        arcpy.MakeRasterLayer_management(pLocalMin, pRLLocalMin) 

        arcpy.SetParameterAsText(5, pRLLocalMin)
        arcpy.SetParameterAsText(6, pRLHandBase) 

